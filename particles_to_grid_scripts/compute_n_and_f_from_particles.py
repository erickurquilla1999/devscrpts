'''
# This script compute n and f from particles data and compare with the data generated by EMU
'''

import numpy as np
import h5py
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib as mpl
from matplotlib.ticker import AutoLocator, AutoMinorLocator, LogLocator
import glob
import os
from particle_interpolator import ParticleInterpolator

###############################################################################
# Usefull functions

def read_hdf5_file(file_name):
    """
    Reads an HDF5 file and returns its datasets as a dictionary.

    Parameters:
        file_name (str): Path to the HDF5 file.

    Returns:
        dict: A dictionary where keys are dataset names and values are NumPy arrays.
    """
    with h5py.File(file_name, 'r') as file:
        return {dataset: np.array(file[dataset]) for dataset in file.keys()}

###############################################################################
# Read and store the allData.h5 file
# The allData.h5 file is generated using the script Emu/Scripts/data_reduction/convertToHDF5.py
# This file contains the number density and flux matrices for each cell
# These quantities are computed on the fly in EMU

file_path = 'allData.h5'
if not os.path.exists(file_path):
    if os.path.exists('../Scripts/data_reduction/convertToHDF5.py'):
        os.system('python ../Scripts/data_reduction/convertToHDF5.py')
    else:
        raise FileNotFoundError("The file allData.h5 does not exist and the script to generate it is not available.")

data_dict = read_hdf5_file(file_path)

if 'N22_Re(1|ccm)' in data_dict:
    n_flavors = 3
elif 'N11_Re(1|ccm)' in data_dict:
    n_flavors = 2
else:
    raise ValueError("The dataset does not contain the expected neutrino flavor data.")

n_plt_grid_files = len(data_dict['N11_Re(1|ccm)'])
print('Number of files with grid information:', n_plt_grid_files)

# cell size
dx = data_dict['dx(cm)'] # cm
dy = data_dict['dy(cm)'] # cm
dz = data_dict['dz(cm)'] # cm
print(f'dx = {dx} cm, dy = {dy} cm, dz = {dz} cm')

# number of cells
Nx = data_dict['Nx'] 
Ny = data_dict['Ny']
Nz = data_dict['Nz']
print(f'Nx = {Nx}, Ny = {Ny}, Nz = {Nz}')

# cell faces
x = np.linspace(0, dx * Nx, Nx + 1) # cm
y = np.linspace(0, dy * Ny, Ny + 1) # cm
z = np.linspace(0, dz * Nz, Nz + 1) # cm

# cell faces mesh
X, Y, Z = np.meshgrid(x, y, z, indexing='ij') # cm

# cell centers
xc = np.linspace(dx / 2, dx * (Nx - 0.5), Nx) # cm
yc = np.linspace(dy / 2, dy * (Ny - 0.5), Ny) # cm
zc = np.linspace(dz / 2, dz * (Nz - 0.5), Nz) # cm

# cell centers mesh
Xc, Yc, Zc = np.meshgrid(xc, yc, zc, indexing='ij') # cm

# 1 index runs over the plt files
# 2 index runs over the cells in the x direction
# 3 index runs over the cells in the y direction
# 4 index runs over the cells in the z direction
# 5 index run 0 for neutrinos and 1 for antineutrinos
# 6 and 7 indices runs over the flavor components
number_density_matrices_from_grid = np.zeros((n_plt_grid_files, Nx, Ny, Nz, 2, n_flavors, n_flavors), dtype=complex) # 1/cm^3

# 1 index runs over the plt files
# 2 index runs over the cells in the x direction
# 3 index runs over the cells in the y direction
# 4 index runs over the cells in the z direction
# 5 index run 0 for neutrinos and 1 for antineutrinos
# 6 and 7 indices runs over the flavor components
# 8 index runs for 0: x flux component, 1: y flux component and 2: z flux component
flux_number_density_matrices_from_grid = np.zeros((n_plt_grid_files, Nx, Ny, Nz, 2, n_flavors, n_flavors, 3), dtype=complex) # 1/cm^3

neutrino_types = ['', 'bar']
components = ['00', '01', '11'] if n_flavors == 2 else ['00', '01', '02', '11', '12', '22']
directions = ['x', 'y', 'z']

for i, nt in enumerate(neutrino_types):
    for comp in components:

        N_re_key = f'N{comp}_Re{nt}(1|ccm)'
        N_im_key = f'N{comp}_Im{nt}(1|ccm)'

        if N_im_key in data_dict:
            number_density_matrices_from_grid[:, :, :, :, i, int(comp[0]), int(comp[1])] = data_dict[N_re_key] + 1.0j * data_dict[N_im_key]
        else:
            number_density_matrices_from_grid[:, :, :, :, i, int(comp[0]), int(comp[1])] = data_dict[N_re_key]
        
        for j, dir in enumerate(directions):

            F_re_key = f'F{dir}{comp}_Re{nt}(1|ccm)'
            F_im_key = f'F{dir}{comp}_Im{nt}(1|ccm)'
            
            if F_im_key in data_dict:
                flux_number_density_matrices_from_grid[:, :, :, :, i, int(comp[0]), int(comp[1]), j] = data_dict[F_re_key] + 1.0j * data_dict[F_im_key]
            else:
                flux_number_density_matrices_from_grid[:, :, :, :, i, int(comp[0]), int(comp[1]), j] = data_dict[F_re_key]

###############################################################################

plo = np.array([0.0,0.0,0.0])
dxi = np.array([1.0/dx,1.0/dy,1.0/dz])
inv_cell_volume = 1.0/(dx*dy*dz)

shape_factor_order_x = 2 if Nx > 1 else 0
shape_factor_order_y = 2 if Ny > 1 else 0
shape_factor_order_z = 2 if Nz > 1 else 0

max_spline_order = 2

plt_particles_files_names = glob.glob("plt*/neutrinos")
plt_particles_files_names = [filename.split('/')[0]+'.h5' for filename in plt_particles_files_names]

if not all(os.path.exists(file) for file in plt_particles_files_names):
    if os.path.exists('../Scripts/collisions/writeparticleinfohdf5.py'):
        os.system('python ../Scripts/collisions/writeparticleinfohdf5.py')
    else:
        raise FileNotFoundError("The file plt*.h5 does not exist and the script to generate it is not available.")

plt_particles_files_names_sorted = sorted(plt_particles_files_names, key=lambda x: int(x.split('plt')[1].split('.h5')[0]))
n_plt_particles_files_names_sorted = len(plt_particles_files_names_sorted)

# 1 index runs over the plt files
# 2 index runs over the cells in the x direction
# 3 index runs over the cells in the y direction
# 4 index runs over the cells in the z direction
# 5 index run 0 for neutrinos and 1 for antineutrinos
# 6 and 7 indices runs over the flavor components
number_density_matrices_from_particles = np.zeros((n_plt_particles_files_names_sorted, Nx, Ny, Nz, 2, n_flavors, n_flavors), dtype=complex) # 1/cm^3

# 1 index runs over the plt files
# 2 index runs over the cells in the x direction
# 3 index runs over the cells in the y direction
# 4 index runs over the cells in the z direction
# 5 index run 0 for neutrinos and 1 for antineutrinos
# 6 and 7 indices runs over the flavor components
# 8 index runs for 0: x flux component, 1: y flux component and 2: z flux component
flux_number_density_matrices_from_particles = np.zeros((n_plt_grid_files, Nx, Ny, Nz, 2, n_flavors, n_flavors, 3), dtype=complex) # 1/cm^3

for f in range(n_plt_particles_files_names_sorted):

    data_dict = read_hdf5_file(plt_particles_files_names_sorted[f])
    n_particles = len(data_dict['N00_Re'])

    # Loop over particles
    for p in range(n_particles):
        
        p_unit = np.array([data_dict['pupx'][p], data_dict['pupy'][p], data_dict['pupz'][p]]) / data_dict['pupt'][p] # Unit momentum vector

        delta_x = ( data_dict['pos_x'][p] - plo[0] ) * dxi[0]
        delta_y = ( data_dict['pos_y'][p] - plo[1] ) * dxi[1]
        delta_z = ( data_dict['pos_z'][p] - plo[2] ) * dxi[2]

        sx =  ParticleInterpolator(max_spline_order, delta_x, shape_factor_order_x)
        sy =  ParticleInterpolator(max_spline_order, delta_y, shape_factor_order_y)
        sz =  ParticleInterpolator(max_spline_order, delta_z, shape_factor_order_z)

        for k in range(sz.first(), sz.last() + 1):
            for j in range(sy.first(), sy.last() + 1):
                for i in range(sx.first(), sx.last() + 1):
                    
                    i_index = i
                    j_index = j
                    k_index = k

                    if i_index < 0: i_index += Nx
                    if j_index < 0: j_index += Ny
                    if k_index < 0: k_index += Nz

                    if i_index >= Nx: i_index -= Nx
                    if j_index >= Ny: j_index -= Ny
                    if k_index >= Nz: k_index -= Nz
                    
                    for l, nt in enumerate(neutrino_types):
                        for comp in components:

                            re_key = f'N{comp}_Re{nt}'
                            im_key = f'N{comp}_Im{nt}'
                            
                            if im_key in data_dict:
                            
                                im_part = sx(i) * sy(j) * sz(k) * inv_cell_volume * data_dict[im_key][p]
                                re_part = sx(i) * sy(j) * sz(k) * inv_cell_volume * data_dict[re_key][p]
                                number_density_matrices_from_particles     [f, i_index, j_index, k_index, l, int(comp[0]), int(comp[1])  ] +=   re_part + 1j * im_part
                                flux_number_density_matrices_from_particles[f, i_index, j_index, k_index, l, int(comp[0]), int(comp[1]),:] += ( re_part + 1j * im_part ) * p_unit

                            else:

                                re_part = sx(i) * sy(j) * sz(k) * inv_cell_volume * data_dict[re_key][p]
                                number_density_matrices_from_particles     [f, i_index, j_index, k_index, l, int(comp[0]), int(comp[1])  ] += re_part
                                flux_number_density_matrices_from_particles[f, i_index, j_index, k_index, l, int(comp[0]), int(comp[1]),:] += re_part * p_unit

###############################################################################
# Computing and saving errors

def compute_percentage_error(true_value, comparison_value):

    diff_real = np.abs(np.real(true_value) - np.real(comparison_value))
    diff_imag = np.abs(np.imag(true_value) - np.imag(comparison_value))
    
    percentage_error_real = 100.0 * np.where(np.abs(np.real(true_value)) != 0, 
                                             diff_real / np.abs(np.real(true_value)), 
                                             np.abs(np.real(comparison_value)))
    
    percentage_error_imag = 100.0 * np.where(np.abs(np.imag(true_value)) != 0, 
                                             diff_imag / np.abs(np.imag(true_value)), 
                                             np.abs(np.imag(comparison_value)))
    
    percentage_error = percentage_error_real + 1j * percentage_error_imag
    return percentage_error

plt_particles_files_names = glob.glob("plt*/neutrinos")
plt_particles_files_names = [filename.split('/')[0] for filename in plt_particles_files_names]
plt_particles_files_names = sorted(plt_particles_files_names, key=lambda x: int(x.split('plt')[1]))

plt_grid_files_names = glob.glob("plt*/Level_0")
plt_grid_files_names = [filename.split('/')[0] for filename in plt_grid_files_names]
plt_grid_files_names = sorted(plt_grid_files_names, key=lambda x: int(x.split('plt')[1]))

mask = [name in plt_particles_files_names for name in plt_grid_files_names]
number_density_matrices_from_grid       = number_density_matrices_from_grid[mask]
flux_number_density_matrices_from_grid = flux_number_density_matrices_from_grid[mask]

percentage_error_in_number_density      = compute_percentage_error(number_density_matrices_from_grid     , number_density_matrices_from_particles     )
percentage_error_in_flux_number_density = compute_percentage_error(flux_number_density_matrices_from_grid, flux_number_density_matrices_from_particles)

output_file = 'compare_emugrid_and_particle_data.h5'

with h5py.File(output_file, 'w') as f:

    for i, nt in enumerate(neutrino_types):
        for comp in components:

            N_re_key = f'N{comp}_Re{nt}(1|ccm)'
            N_im_key = f'N{comp}_Im{nt}(1|ccm)'

            if N_im_key in data_dict:
                f.create_dataset(N_re_key+'_percentage_error', data=np.real(percentage_error_in_number_density[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_im_key+'_percentage_error', data=np.imag(percentage_error_in_number_density[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_re_key+'_particles', data=np.real(number_density_matrices_from_particles[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_im_key+'_particles', data=np.imag(number_density_matrices_from_particles[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_re_key+'_grid', data=np.real(number_density_matrices_from_grid[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_im_key+'_grid', data=np.imag(number_density_matrices_from_grid[:,:,:,:,i,int(comp[0]),int(comp[1])]))
            else:
                f.create_dataset(N_re_key+'_percentage_error', data=np.real(percentage_error_in_number_density[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_re_key+'_particles', data=np.real(number_density_matrices_from_particles[:,:,:,:,i,int(comp[0]),int(comp[1])]))
                f.create_dataset(N_re_key+'_grid', data=np.real(number_density_matrices_from_grid[:,:,:,:,i,int(comp[0]),int(comp[1])]))

            for j, dir in enumerate(directions):

                F_re_key = f'F{dir}{comp}_Re{nt}(1|ccm)'
                F_im_key = f'F{dir}{comp}_Im{nt}(1|ccm)'
                
                if F_im_key in data_dict:
                    f.create_dataset(F_re_key+'_percentage_error', data=np.real(percentage_error_in_flux_number_density[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_im_key+'_percentage_error', data=np.imag(percentage_error_in_flux_number_density[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_re_key+'_particles', data=np.real(flux_number_density_matrices_from_particles[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_im_key+'_particles', data=np.imag(flux_number_density_matrices_from_particles[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_re_key+'_grid', data=np.real(flux_number_density_matrices_from_grid[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_im_key+'_grid', data=np.imag(flux_number_density_matrices_from_grid[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                else:
                    f.create_dataset(F_re_key+'_percentage_error', data=np.real(percentage_error_in_flux_number_density[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_re_key+'_particles', data=np.real(flux_number_density_matrices_from_particles[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))
                    f.create_dataset(F_re_key+'_grid', data=np.real(flux_number_density_matrices_from_grid[:,:,:,:,i,int(comp[0]),int(comp[1]),j]))